#include <stdint.h>
#include "params.h"
#include "ntt.h"
#include "reduce.h"

/* Code to generate zetas and zetas_inv used in the number-theoretic transform:

#define KYBER_ROOT_OF_UNITY 17

static const uint16_t tree[128] = {
  0, 64, 32, 96, 16, 80, 48, 112, 8, 72, 40, 104, 24, 88, 56, 120,
  4, 68, 36, 100, 20, 84, 52, 116, 12, 76, 44, 108, 28, 92, 60, 124,
  2, 66, 34, 98, 18, 82, 50, 114, 10, 74, 42, 106, 26, 90, 58, 122,
  6, 70, 38, 102, 22, 86, 54, 118, 14, 78, 46, 110, 30, 94, 62, 126,
  1, 65, 33, 97, 17, 81, 49, 113, 9, 73, 41, 105, 25, 89, 57, 121,
  5, 69, 37, 101, 21, 85, 53, 117, 13, 77, 45, 109, 29, 93, 61, 125,
  3, 67, 35, 99, 19, 83, 51, 115, 11, 75, 43, 107, 27, 91, 59, 123,
  7, 71, 39, 103, 23, 87, 55, 119, 15, 79, 47, 111, 31, 95, 63, 127
};

void init_ntt() {
  unsigned int i, j, k;
  int16_t tmp[128];

  tmp[0] = MONT;
  for(i = 1; i < 128; ++i)
    tmp[i] = fqmul(tmp[i-1], KYBER_ROOT_OF_UNITY*MONT % KYBER_Q);

  for(i = 0; i < 128; ++i)
    zetas[i] = tmp[tree[i]];

  k = 0;
  for(i = 64; i >= 1; i >>= 1)
    for(j = i; j < 2*i; ++j)
      zetas_inv[k++] = -tmp[128 - tree[j]];

  zetas_inv[127] = MONT * (MONT * (KYBER_Q - 1) * ((KYBER_Q - 1)/128) % KYBER_Q) % KYBER_Q;
}

*/

const int16_t zetas[128] = {
  2285, 2571, 2970, 1812, 1493, 1422, 287, 202, 3158, 622, 1577, 182, 962,
  2127, 1855, 1468, 573, 2004, 264, 383, 2500, 1458, 1727, 3199, 2648, 1017,
  732, 608, 1787, 411, 3124, 1758, 1223, 652, 2777, 1015, 2036, 1491, 3047,
  1785, 516, 3321, 3009, 2663, 1711, 2167, 126, 1469, 2476, 3239, 3058, 830,
  107, 1908, 3082, 2378, 2931, 961, 1821, 2604, 448, 2264, 677, 2054, 2226,
  430, 555, 843, 2078, 871, 1550, 105, 422, 587, 177, 3094, 3038, 2869, 1574,
  1653, 3083, 778, 1159, 3182, 2552, 1483, 2727, 1119, 1739, 644, 2457, 349,
  418, 329, 3173, 3254, 817, 1097, 603, 610, 1322, 2044, 1864, 384, 2114, 3193,
  1218, 1994, 2455, 220, 2142, 1670, 2144, 1799, 2051, 794, 1819, 2475, 2459,
  478, 3221, 3021, 996, 991, 958, 1869, 1522, 1628
};

const int16_t zetas_inv[128] = {
  1701, 1807, 1460, 2371, 2338, 2333, 308, 108, 2851, 870, 854, 1510, 2535,
  1278, 1530, 1185, 1659, 1187, 3109, 874, 1335, 2111, 136, 1215, 2945, 1465,
  1285, 2007, 2719, 2726, 2232, 2512, 75, 156, 3000, 2911, 2980, 872, 2685,
  1590, 2210, 602, 1846, 777, 147, 2170, 2551, 246, 1676, 1755, 460, 291, 235,
  3152, 2742, 2907, 3224, 1779, 2458, 1251, 2486, 2774, 2899, 1103, 1275, 2652,
  1065, 2881, 725, 1508, 2368, 398, 951, 247, 1421, 3222, 2499, 271, 90, 853,
  1860, 3203, 1162, 1618, 666, 320, 8, 2813, 1544, 282, 1838, 1293, 2314, 552,
  2677, 2106, 1571, 205, 2918, 1542, 2721, 2597, 2312, 681, 130, 1602, 1871,
  829, 2946, 3065, 1325, 2756, 1861, 1474, 1202, 2367, 3147, 1752, 2707, 171,
  3127, 3042, 1907, 1836, 1517, 359, 758, 1441
};

// in the order that the invntt_CG needs one by one innermost for loop, in Montgomery domain
const int16_t zetas_inv_in_order[128] = {
  1701, 75, 1659, 1676, 2851, 2210, 2945, 3224, 
  2338, 2980, 1335, 235, 2535, 147, 2719, 2486, 
  1460, 3000, 3109, 460, 854, 1846, 1285, 2458, 
  308, 2685, 136, 2742, 1530, 2551, 2232, 2899, 
  1807, 156, 1187, 1755, 870, 602, 1465, 1779, 
  2333, 872, 2111, 3152, 1278, 2170, 2726, 2774, 
  2371, 2911, 874, 291, 1510, 777, 2007, 1251, 
  108, 1590, 1215, 2907, 1185, 246, 2512, 1103, 
  1275, 1860, 951, 1544, 725, 666, 2499, 2314, 
  1065, 1162, 1421, 1838, 2368, 8, 90, 2677, 
  2652, 3203, 247, 282, 1508, 320, 271, 552, 
  2881, 1618, 3222, 1293, 398, 2813, 853, 2106, 
  1571, 130, 2721, 2946, 2918, 1871, 2312, 1325, 
  205, 1602, 2597, 3065, 1542, 829, 681, 2756, 
  1861, 3147, 1202, 2707, 1474, 1752, 2367, 171, 
  3127, 1907, 3042, 1836, 1517, 359, 758, 0
};

/****************************************************************************************************************************
*in the order that the invntt_CG needs one by one innermost for loop, in Montgomery domain (split into stages for SCA usage)
****************************************************************************************************************************/
const int16_t zetas_inv_in_order_stage1[128]={
  1701,1701,75,75,1659,1659,1676,1676,
  2851,2851,2210,2210,2945,2945,3224,3224,
  2338,2338,2980,2980,1335,1335,235,235,
  2535,2535,147,147,2719,2719,2486,2486,
  1460,1460,3000,3000,3109,3109,460,460,
  854,854,1846,1846,1285,1285,2458,2458,
  308,308,2685,2685,136,136,2742,2742,
  1530,1530,2551,2551,2232,2232,2899,2899,
  1807,1807,156,156,1187,1187,1755,1755,
  870,870,602,602,1465,1465,1779,1779,
  2333,2333,872,872,2111,2111,3152,3152,
  1278,1278,2170,2170,2726,2726,2774,2774,
  2371,2371,2911,2911,874,874,291,291,
  1510,1510,777,777,2007,2007,1251,1251,
  108,108,1590,1590,1215,1215,2907,2907,
  1185,1185,246,246,2512,2512,1103,1103
};

const int16_t zetas_inv_in_order_stage2[128]={
  1275,1275,1275,1275,1860,1860,1860,1860,
  951,951,951,951,1544,1544,1544,1544,
  725,725,725,725,666,666,666,666,
  2499,2499,2499,2499,2314,2314,2314,2314,
  1065,1065,1065,1065,1162,1162,1162,1162,
  1421,1421,1421,1421,1838,1838,1838,1838,
  2368,2368,2368,2368,8,8,8,8,
  90,90,90,90,2677,2677,2677,2677,
  2652,2652,2652,2652,3203,3203,3203,3203,
  247,247,247,247,282,282,282,282,
  1508,1508,1508,1508,320,320,320,320,
  271,271,271,271,552,552,552,552,
  2881,2881,2881,2881,1618,1618,1618,1618,
  3222,3222,3222,3222,1293,1293,1293,1293,
  398,398,398,398,2813,2813,2813,2813,
  853,853,853,853,2106,2106,2106,2106
};

const int16_t zetas_inv_in_order_stage3[128]={
  1571,1571,1571,1571,1571,1571,1571,1571,
  130,130,130,130,130,130,130,130,
  2721,2721,2721,2721,2721,2721,2721,2721,
  2946,2946,2946,2946,2946,2946,2946,2946,
  2918,2918,2918,2918,2918,2918,2918,2918,
  1871,1871,1871,1871,1871,1871,1871,1871,
  2312,2312,2312,2312,2312,2312,2312,2312,
  1325,1325,1325,1325,1325,1325,1325,1325,
  205,205,205,205,205,205,205,205,
  1602,1602,1602,1602,1602,1602,1602,1602,
  2597,2597,2597,2597,2597,2597,2597,2597,
  3065,3065,3065,3065,3065,3065,3065,3065,
  1542,1542,1542,1542,1542,1542,1542,1542,
  829,829,829,829,829,829,829,829,
  681,681,681,681,681,681,681,681,
  2756,2756,2756,2756,2756,2756,2756,2756
};

const int16_t zetas_inv_in_order_stage4[128]={
  1861,1861,1861,1861,1861,1861,1861,1861,
  1861,1861,1861,1861,1861,1861,1861,1861,
  3147,3147,3147,3147,3147,3147,3147,3147,
  3147,3147,3147,3147,3147,3147,3147,3147,
  1202,1202,1202,1202,1202,1202,1202,1202,
  1202,1202,1202,1202,1202,1202,1202,1202,
  2707,2707,2707,2707,2707,2707,2707,2707,
  2707,2707,2707,2707,2707,2707,2707,2707,
  1474,1474,1474,1474,1474,1474,1474,1474,
  1474,1474,1474,1474,1474,1474,1474,1474,
  1752,1752,1752,1752,1752,1752,1752,1752,
  1752,1752,1752,1752,1752,1752,1752,1752,
  2367,2367,2367,2367,2367,2367,2367,2367,
  2367,2367,2367,2367,2367,2367,2367,2367,
  171,171,171,171,171,171,171,171,
  171,171,171,171,171,171,171,171
};

const int16_t zetas_inv_in_order_stage5[128]={
  3127,3127,3127,3127,3127,3127,3127,3127,
  3127,3127,3127,3127,3127,3127,3127,3127,
  3127,3127,3127,3127,3127,3127,3127,3127,
  3127,3127,3127,3127,3127,3127,3127,3127,
  1907,1907,1907,1907,1907,1907,1907,1907,
  1907,1907,1907,1907,1907,1907,1907,1907,
  1907,1907,1907,1907,1907,1907,1907,1907,
  1907,1907,1907,1907,1907,1907,1907,1907,
  3042,3042,3042,3042,3042,3042,3042,3042,
  3042,3042,3042,3042,3042,3042,3042,3042,
  3042,3042,3042,3042,3042,3042,3042,3042,
  3042,3042,3042,3042,3042,3042,3042,3042,
  1836,1836,1836,1836,1836,1836,1836,1836,
  1836,1836,1836,1836,1836,1836,1836,1836,
  1836,1836,1836,1836,1836,1836,1836,1836,
  1836,1836,1836,1836,1836,1836,1836,1836
};

const int16_t zetas_inv_in_order_stage6[128]={
  1517,1517,1517,1517,1517,1517,1517,1517,
  1517,1517,1517,1517,1517,1517,1517,1517,
  1517,1517,1517,1517,1517,1517,1517,1517,
  1517,1517,1517,1517,1517,1517,1517,1517,
  1517,1517,1517,1517,1517,1517,1517,1517,
  1517,1517,1517,1517,1517,1517,1517,1517,
  1517,1517,1517,1517,1517,1517,1517,1517,
  1517,1517,1517,1517,1517,1517,1517,1517,
  359,359,359,359,359,359,359,359,
  359,359,359,359,359,359,359,359,
  359,359,359,359,359,359,359,359,
  359,359,359,359,359,359,359,359,
  359,359,359,359,359,359,359,359,
  359,359,359,359,359,359,359,359,
  359,359,359,359,359,359,359,359,
  359,359,359,359,359,359,359,359
};

const int16_t zetas_inv_in_order_stage7[128]={
  758,758,758,758,758,758,758,758,
  758,758,758,758,758,758,758,758,
  758,758,758,758,758,758,758,758,
  758,758,758,758,758,758,758,758,
  758,758,758,758,758,758,758,758,
  758,758,758,758,758,758,758,758,
  758,758,758,758,758,758,758,758,
  758,758,758,758,758,758,758,758,
  758,758,758,758,758,758,758,758,
  758,758,758,758,758,758,758,758,
  758,758,758,758,758,758,758,758,
  758,758,758,758,758,758,758,758,
  758,758,758,758,758,758,758,758,
  758,758,758,758,758,758,758,758,
  758,758,758,758,758,758,758,758,
  758,758,758,758,758,758,758,758
};

const uint16_t tree_128_NWC[128] = {  // In a order of tree[i] = br7(i) for i = 0, . . . , 127, where br7(i) is the bit reversal of the unsigned 7-bit integer i
  0, 64, 32, 96, 16, 80, 48, 112, 8, 72, 40, 104, 24, 88, 56, 120,
  4, 68, 36, 100, 20, 84, 52, 116, 12, 76, 44, 108, 28, 92, 60, 124,
  2, 66, 34, 98, 18, 82, 50, 114, 10, 74, 42, 106, 26, 90, 58, 122,
  6, 70, 38, 102, 22, 86, 54, 118, 14, 78, 46, 110, 30, 94, 62, 126,
  1, 65, 33, 97, 17, 81, 49, 113, 9, 73, 41, 105, 25, 89, 57, 121,
  5, 69, 37, 101, 21, 85, 53, 117, 13, 77, 45, 109, 29, 93, 61, 125,
  3, 67, 35, 99, 19, 83, 51, 115, 11, 75, 43, 107, 27, 91, 59, 123,
  7, 71, 39, 103, 23, 87, 55, 119, 15, 79, 47, 111, 31, 95, 63, 127
};

// the byte offset of even index coefficients after NTT_cg
const uint16_t byteoffset_even[128] = {
0, 256, 128, 384, 64, 320, 192, 448, 32, 288, 160, 416, 96, 352, 224, 480,
16, 272, 144, 400, 80, 336, 208, 464, 48, 304, 176, 432, 112, 368, 240, 496,
8, 264, 136, 392, 72, 328, 200, 456, 40, 296, 168, 424, 104, 360, 232, 488,
24, 280, 152, 408, 88, 344, 216, 472, 56, 312, 184, 440, 120, 376, 248, 504,
4, 260, 132, 388, 68, 324, 196, 452, 36, 292, 164, 420, 100, 356, 228, 484,
20, 276, 148, 404, 84, 340, 212, 468, 52, 308, 180, 436, 116, 372, 244, 500,
12, 268, 140, 396, 76, 332, 204, 460, 44, 300, 172, 428, 108, 364, 236, 492,
28, 284, 156, 412, 92, 348, 220, 476, 60, 316, 188, 444, 124, 380, 252, 508
};

const uint16_t byteoffset_total[256]={
  0,256,128,384,64,320,192,448,32,288,160,416,96,352,224,480,
  16,272,144,400,80,336,208,464,48,304,176,432,112,368,240,496,
  8,264,136,392,72,328,200,456,40,296,168,424,104,360,232,488,
  24,280,152,408,88,344,216,472,56,312,184,440,120,376,248,504,
  4,260,132,388,68,324,196,452,36,292,164,420,100,356,228,484,
  20,276,148,404,84,340,212,468,52,308,180,436,116,372,244,500,
  12,268,140,396,76,332,204,460,44,300,172,428,108,364,236,492,
  28,284,156,412,92,348,220,476,60,316,188,444,124,380,252,508,
  2,258,130,386,66,322,194,450,34,290,162,418,98,354,226,482,
  18,274,146,402,82,338,210,466,50,306,178,434,114,370,242,498,
  10,266,138,394,74,330,202,458,42,298,170,426,106,362,234,490,
  26,282,154,410,90,346,218,474,58,314,186,442,122,378,250,506,
  6,262,134,390,70,326,198,454,38,294,166,422,102,358,230,486,
  22,278,150,406,86,342,214,470,54,310,182,438,118,374,246,502,
  14,270,142,398,78,334,206,462,46,302,174,430,110,366,238,494,
  30,286,158,414,94,350,222,478,62,318,190,446,126,382,254,510
};

// zetas used in basemul which cooperate with CG NTT/INTT, in Montgomery domain
// CG NTT output is special bit-reversed order, and before basemul, we reorder it to standard order
// to prepare for CG INTT
const int16_t zetas_basemul_cg[KYBER_N / 2] = {
  2226, 817, 3083, 2144, 422, 2114, 1739, 3221, 
  2078, 1322, 2552, 1819, 3038, 2455, 418, 958, 
  555, 603, 1159, 2051, 177, 1218, 2457, 996, 
  1550, 1864, 2727, 2459, 1574, 2142, 3173, 1522, 
  430, 1097, 778, 1799, 587, 3193, 644, 3021, 
  871, 2044, 1483, 2475, 2869, 220, 329, 1869, 
  843, 610, 3182, 794, 3094, 1994, 349, 991, 
  105, 384, 1119, 478, 1653, 1670, 3254, 1628, 
  1103, 2512, 246, 1185, 2907, 1215, 1590, 108, 
  1251, 2007, 777, 1510, 291, 874, 2911, 2371, 
  2774, 2726, 2170, 1278, 3152, 2111, 872, 2333, 
  1779, 1465, 602, 870, 1755, 1187, 156, 1807, 
  2899, 2232, 2551, 1530, 2742, 136, 2685, 308, 
  2458, 1285, 1846, 854, 460, 3109, 3000, 1460, 
  2486, 2719, 147, 2535, 235, 1335, 2980, 2338, 
  3224, 2945, 2210, 2851, 1676, 1659, 75, 1701
};

/*************************************************
* Name:        fqmul
*
* Description: Multiplication followed by Montgomery reduction
*
* Arguments:   - int16_t a: first factor
*              - int16_t b: second factor
*
* Returns 16-bit integer congruent to a*b*R^{-1} mod q
**************************************************/
static int16_t fqmul(int16_t a, int16_t b) {
  return montgomery_reduce((int32_t)a*b);
}

/*************************************************
* Name:        ntt
*
* Description: Inplace number-theoretic transform (NTT) in Rq
*              input is in standard order, output is in bitreversed order
*
* Arguments:   - int16_t r[256]: pointer to input/output vector of elements
*                                of Zq
**************************************************/
void ntt(int16_t r[256]) {
  unsigned int len, start, j, k;
  int16_t t, zeta;

  k = 1;
  for(len = 128; len >= 2; len >>= 1) {
    for(start = 0; start < 256; start = j + len) {
      zeta = zetas[k++];
      for(j = start; j < start + len; ++j) {
        t = fqmul(zeta, r[j + len]);
        r[j + len] = r[j] - t;
        r[j] = r[j] + t;
      }
    }
  }
}

/*************************************************
* Name:        invntt_tomont
*
* Description: Inplace inverse number-theoretic transform in Rq and
*              multiplication by Montgomery factor 2^16.
*              Input is in bitreversed order, output is in standard order
*
* Arguments:   - int16_t r[256]: pointer to input/output vector of elements
*                                of Zq
**************************************************/
void invntt(int16_t r[256]) {
  unsigned int start, len, j, k;
  int16_t t, zeta;

  k = 0;
  for(len = 2; len <= 128; len <<= 1) {
    for(start = 0; start < 256; start = j + len) {
      zeta = zetas_inv[k++];
      for(j = start; j < start + len; ++j) {
        t = r[j];
        r[j] = barrett_reduce(t + r[j + len]);
        r[j + len] = t - r[j + len];
        r[j + len] = fqmul(zeta, r[j + len]);
      }
    }
  }

  for(j = 0; j < 256; ++j)
    r[j] = fqmul(r[j], zetas_inv[127]);
}

/*************************************************
* Name:        invntt_without_post_process
*
* Description: Inplace inverse number-theoretic transform in Rq.
*              Input is in bitreversed order and in normal domain,
*              output is in standard order and normal domain.
*
* Arguments:   - int16_t r[256]: pointer to input/output vector of elements
*                                of Zq
**************************************************/
void invntt_without_post_process(int16_t r[KYBER_N]) {
    unsigned int start, len, j, k;
    int16_t t0, t1, zeta;

    k = 0;
    for (len = 2; len <= KYBER_N / 2; len <<= 1) {
        for (start = 0; start < KYBER_N; start = j + len) {
            zeta = zetas_inv[k++];
            for (j = start; j < start + len; ++j) {
                t0 = barrett_reduce(r[j] + r[j + len]);
                t1 = r[j] - r[j + len];

                r[j] = mod_div2(t0);
                r[j+len] = mod_div2(t1);

                r[j + len] = fqmul(zeta, r[j + len]);
            }
        }
    }
}

/*************************************************
* Name:        basemul
*
* Description: Multiplication of polynomials in Zq[X]/(X^2-zeta)
*              used for multiplication of elements in Rq in NTT domain
*
* Arguments:   - int16_t r[2]:       pointer to the output polynomial
*              - const int16_t a[2]: pointer to the first factor
*              - const int16_t b[2]: pointer to the second factor
*              - int16_t zeta:       integer defining the reduction polynomial
**************************************************/
void basemul(int16_t r[2],
             const int16_t a[2],
             const int16_t b[2],
             int16_t zeta)
{
  r[0]  = fqmul(a[1], b[1]);
  r[0]  = fqmul(r[0], zeta);
  r[0] += fqmul(a[0], b[0]);

  r[1]  = fqmul(a[0], b[1]);
  r[1] += fqmul(a[1], b[0]);
}

void copy_array(int16_t a[KYBER_N], int16_t temp[KYBER_N]) {
    uint32_t i;
    for (i = 0; i < KYBER_N; i++) {
        a[i] = temp[i];
    }
}


/*************************************************
* Name:        ntt_CG
*
* Description: Forward NTT, out-of place, constant geometry.
*                     No modular reduction is performed after additions or subtractions.
*                     Input vector is in standard order and normal domain
*                     Output vector is in bitreversed order and normal domain.
*                    Incomplete NTT, actually perform two 128-point NTT,
*                    output coefficients are in Zq[X]/(X^2-ω).
* 注意:   incomplete CG NTT 输出的 bit-reversed order 和 
*           上面的 in-place NTT 输出的 bit-reversed order 是不同的。
*           ntt_CG 函数 输出的256点系数，从中间 (128次序) 分为两组：
*           第一组(0次序到127次序)对应 in-place NTT 输出中的 偶次序系数，
*           第二组(128次序到255次序)对应 in-place NTT 输出中的奇次序系数。
*           第一组和第二组内的128点系数的次序都是bit-reversed，
*           例如，如果组内是顺序，那么a[2]应该位于第一组1次序 (第一组内只含偶数，0是次序0的偶数，2是次序1的偶数)，
*           但是 bit-reversed order下，a[2]位于第一组br(1)=64次序.
*
* Arguments:   - int32_t p[N]: input/output coefficient array
**************************************************/
void ntt_CG(int16_t a[KYBER_N]) {
    unsigned int m, i;
    unsigned int t;
    int16_t zeta;
    int16_t temp[KYBER_N] = { 0 };

    for (m = 1; m < KYBER_N / 2; m *= 2) {
    // for (m = 1; m < 128; m *= 2) {
        // 数据流特点 : 相邻的 m 组蝶形操作看作一个蝶形操作集合，同一集合内的蝶形计算的旋转因子都不同，不同的蝶形运算集合中次序相同的蝶形运算的旋转因子相同
        // 每一stage需要 m 个不同的旋转因子
        // 但从向量化的角度，还是按数据流中蝶形操作的顺序，从上向下计算了；而不是复用相同的旋转因子，令不同的蝶形运算集合中次序相同的蝶形运算并行计算
        for (i = 0; i < KYBER_N / 2; i++) {
            zeta = zetas[m + (i % m)];
            t = fqmul(zeta, a[i + KYBER_N / 2]);
            temp[2 * i] = a[i] + t;
            temp[2 * i + 1] = a[i] - t;
        }
        copy_array(a, temp);
    }
}

/*************************************************
* Name:        bitreverse_to_standard_all
*
* Description: Transfer a array of KYBER_N coefficients in bitreverse order after NTT to standard order
*
* Arguments:   - int32_t a[N]: input/output coefficient array
**************************************************/
void bitreverse_to_standard_all(int16_t a[KYBER_N]) {
    uint32_t i;
    uint32_t index_of_even, index_of_odd, index_of_all;
    int16_t temp[KYBER_N] = { 0 };

    for (i = 0; i < KYBER_N; i++) {
        if ((i & 0x1) == 0) {      // even index coefficients
            index_of_even = tree_128_NWC[i/2];
            index_of_all = index_of_even * 2;
        }
        else {                              // odd index coefficients
            index_of_odd = tree_128_NWC[i/2];
            index_of_all = index_of_odd * 2 + 1;
        }
        temp[index_of_all] = a[i];
    }
    copy_array(a, temp);
}

/*************************************************
* Name:        bitreverse_cg_to_standard_all
*
* Description: Transfer a array of KYBER_N coefficients in special bitreverse order after CG-NTT to standard order
*
* Arguments:   - int32_t a[N]: input/output coefficient array
**************************************************/
void bitreverse_cg_to_standard_all(int16_t a[KYBER_N]) {
    uint32_t i;
    uint32_t index_of_even, index_of_odd, index_of_all;
    int16_t temp[KYBER_N] = { 0 };

    for (i = 0; i < KYBER_N; i++) {
        if (i < KYBER_N / 2) {      // even index coefficients
            index_of_even = tree_128_NWC[i];
            index_of_all = index_of_even * 2;
        }
        else {                              // odd index coefficients
            index_of_odd = tree_128_NWC[i - 128];
            index_of_all = index_of_odd * 2 + 1;
        }
        temp[index_of_all] = a[i];
    }
    copy_array(a, temp);
}

/*************************************************
* Name:        standard_to_bitreverse_all
*
* Description: Transfer a array of KYBER_N coefficients in standard order to bitreverse order (the order after NTT)
*
* Arguments:   - int32_t a[N]: input/output coefficient array
**************************************************/
void standard_to_bitreverse_all(int16_t a[KYBER_N]) {
  uint32_t i;
  uint32_t index_of_all;
  int16_t temp[KYBER_N] = { 0 };

  for(i = 0; i < KYBER_N; i++) {
    if ((i & 0x1) == 0) {      // even index coefficients
      index_of_all = tree_128_NWC[i/2] * 2;
    }
    else {                    // odd index coefficients
      index_of_all = tree_128_NWC[i/2] * 2 + 1;
    }
    temp[index_of_all] = a[i];    
  }
  copy_array(a, temp);
}

/*************************************************
* Name:        invntt_CG
*
* Description: Inverse NTT.
*              Out-of-place, constant geometry.
*              Input coefficients are in standard order and normal domain.
*              Output coefficient are smaller than Q in absolute value;
*              and output coefficients are in bit-reversed order and normal domain.
*
* Arguments:   - int16_t p[N]: input/output coefficient array
**************************************************/
void invntt_CG(int16_t a[KYBER_N]) {
  unsigned int m, i, j;
  unsigned int r_pos, w_pos;
  int16_t zeta, t0, t1;
  int16_t temp[KYBER_N] = { 0 };

  uint32_t k = 0;     // index to access zetas_inv_in_order
  for (m = 2; m < KYBER_N; m *= 2) {
    // 数据流特点 : 相邻的 m 组 蝶形操作 使用相同的旋转因子，看作一个蝶形操作集合；每一stage存在 N/2m 个蝶形操作集合，其使用的旋转因子各不相同
    // 每一stage需要 N/2m 个不同的旋转因子
    // 从向量化的角度，可将 每一个 stage 的 N/2 组蝶形计算 分为 N/2m 个蝶形操作集合，蝶形操作集合内复用旋转因子
    for (i = 0; i < KYBER_N / (2 * m); i++) {
      zeta = zetas_inv_in_order[k++];

      for (j = 0; j < m; j++) {
        r_pos = i * m + j;
        w_pos = i * (2 * m) + 2 * j;
        t0 = central_reduce_oneQ(a[r_pos] + a[r_pos + KYBER_N / 2]);
        t1 = central_reduce_oneQ(a[r_pos] - a[r_pos + KYBER_N / 2]);

        temp[w_pos] = mod_div2(t0);
        temp[w_pos + 1] = mod_div2(t1);

        temp[w_pos + 1] = fqmul(zeta, temp[w_pos + 1]);
      }
    }
    copy_array(a, temp);
  }
}